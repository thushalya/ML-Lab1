# -*- coding: utf-8 -*-
"""ML-lab1-label1-190676J.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o2ovA1azUgXGBRt4fP_DW0N4lkCiVqfI
"""

from google.colab import drive
drive.mount('/content/drive')

"""Import necssary libraries and modules"""

#import libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.feature_selection import VarianceThreshold
from sklearn.model_selection import cross_val_score


from sklearn.metrics import accuracy_score, precision_score, recall_score

"""Import training, validation and testing datasets"""

# File paths for the datasets
train_path = '/content/drive/MyDrive/Colab Notebooks/Lab1/train.csv'
valid_path = '/content/drive/MyDrive/Colab Notebooks/Lab1/valid.csv'
test_path = '/content/drive/MyDrive/Colab Notebooks/Lab1/test.csv'

# Load the train dataset
train_data = pd.read_csv(train_path)
# Load the valid dataset
valid_data = pd.read_csv(valid_path)
# Load the test dataset
test_data = pd.read_csv(test_path)

"""Visualize original training data"""

train_data.head()

"""Prepare the data by eliminating any null values in the target labels and making educated guesses to fill in missing values in the features.

Remove the columns in the training dataset where there are null values in the labels.
"""

# Assess the presence of null values in the training dataset
train_null_counts = train_data.isnull().sum()
print("Null value counts in the training dataset: \n{}".format(train_null_counts))

# Remove rows containing null values in the last four columns (representing target labels) in the training dataset
train_data = train_data.dropna(subset=train_data.columns[-4:], how='any')

"""Impute null values in the features of the train, valid, and test datasets by replacing them with their respective means."""

# Replace null values with the mean in the training dataset
train_data = train_data.fillna(train_data.mean())

# Replace null values with the mean in the validation dataset
valid_data = valid_data.fillna(valid_data.mean())

# Replace null values with the mean in the test dataset
test_data = test_data.fillna(test_data.mean())

"""Visualize processed training data"""

train_data.head()

"""Separate features and labels in the train, valid and test datasets"""

# Split the train dataset into features and labels
train_features = train_data.iloc[:, :-4]
train_labels = train_data.iloc[:, -4:]

# Split the validation dataset into features and labels
valid_features = valid_data.iloc[:, :-4]
valid_labels = valid_data.iloc[:, -4:]

# Split the test dataset into features and labels
test_features = test_data.iloc[:, :-4]
test_labels = test_data.iloc[:, -4:]

"""Extract the first label in the train, valid and test datasets"""

# Extract the first label from the training dataset
train_label1 = train_labels.iloc[:, 0]

# Extract the first label from the validation dataset
valid_label1 = valid_labels.iloc[:, 0]

# Extract the first label from the test dataset
test_label1 = test_labels.iloc[:, 0]

"""# Making predictions for Label 1 without performing any feature engineering.

Predict label 1 without feature engineering steps and techniques

Make copies of the features and labels of the datasets to be used in the models without feature engineering
"""

# Create copies of features and labels in the training dataset
train_features_copy = train_features.copy()
train_labels_copy = train_labels.copy()

# Create copies of features and labels in the validation dataset
valid_features_copy = valid_features.copy()
valid_labels_copy = valid_labels.copy()

# Create copies of features and labels in the test dataset
test_features_copy = test_features.copy()
test_labels_copy = test_labels.copy()

"""Make copies of the label 1 of the datasets to be used in the models without feature engineering"""

# Make a copy of the first label of the train dataset
train_label1_copy = train_label1.copy()

# Make a copy of the first label of the valid dataset
valid_label1_copy = valid_label1.copy()

# Make a copy of the first label of the test dataset
test_label1_copy = test_label1.copy()

"""Standardize the features of all datasets"""

# Apply standardization to the feature data
feature_scaler = StandardScaler()
train_features_copy = feature_scaler.fit_transform(train_features_copy)
valid_features_copy = feature_scaler.transform(valid_features_copy)
test_features_copy = feature_scaler.transform(test_features_copy)

"""Use the raw scaled features to train the best model which is SVM"""

best_model = SVC()

best_model.fit(train_features_copy, train_label1_copy)

"""Used the trained model on all features to predict the valid and get metrics"""

# Make predictions on the training data using the best model
y_pred_train = best_model.predict(train_features_copy)

# Calculate classification metrics for the training dataset
accuracy_train = accuracy_score(train_label1_copy, y_pred_train)
precision_train = precision_score(train_label1_copy, y_pred_train, average='weighted', zero_division=1)
recall_train = recall_score(train_label1_copy, y_pred_train, average='weighted')

print(f"Classification Metrics for SVM on the training data:")
print(f"Accuracy: {accuracy_train:.2f}")
print(f"Precision: {precision_train:.2f}")
print(f"Recall: {recall_train:.2f}")
print("\n")

# Make predictions on the validation data using the best model
y_pred_valid = best_model.predict(valid_features_copy)

# Calculate classification metrics for the validation dataset
accuracy_valid = accuracy_score(valid_label1_copy, y_pred_valid)
precision_valid = precision_score(valid_label1_copy, y_pred_valid, average='weighted', zero_division=1)
recall_valid = recall_score(valid_label1_copy, y_pred_valid, average='weighted')

print(f"Classification Metrics for SVM on the validation data:")
print(f"Accuracy: {accuracy_valid:.2f}")
print(f"Precision: {precision_valid:.2f}")
print(f"Recall: {recall_valid:.2f}")
print("\n")



"""Predict the label 1 on test data"""

# Predict on the test data
y_pred_base_test = best_model.predict(test_features_copy)

"""# Making predictions for Label 1 performing feature engineering.

Predict label 1 with feature engineering steps and techniques

## Feature Engineering

Use feature selection based on correlation matrix and feature extraction based on PCA

### Feature Selection

Visualize the distribution of the training label 1
"""

# Visualize the distribution of the first target label in the training dataset
unique_labels, label_counts = np.unique(train_label1, return_counts=True)

plt.figure(figsize=(22, 6))
plt.xticks(unique_labels)
plt.bar(unique_labels, label_counts, color='lightcoral')
plt.xlabel('Label 1')
plt.ylabel('Count')
plt.title('Distribution of Label 1 in Training Data')
plt.show()

"""Calculate the variance between values in each feature remove unwanted features"""

# Assuming you have loaded your dataset into train_features
# Calculate the variance for each feature
variances = train_features.var()

# Set a threshold for minimum variance (you can adjust this threshold)
min_variance_threshold = 0.01

# Create a mask of features that meet the variance threshold
mask = variances >= min_variance_threshold

# Invert the mask to select features to remove
features_to_remove = train_features.columns[~mask]

# Remove the selected features from train_features
train_features = train_features.drop(columns=features_to_remove)


"""Calculate the correlation matrix of the training data features"""

# Compute the correlation matrix among the features
correlation_matrix = train_features.corr()

# Create a mask for the upper triangle of the correlation matrix
mask = np.triu(np.ones_like(correlation_matrix))

# Generate a heatmap to visualize the correlation matrix using seaborn
plt.figure(figsize=(12, 12))
sns.heatmap(correlation_matrix, cmap='gray', center=0, mask=mask)
plt.title("Correlation Matrix")
plt.show()

"""Identify the features that are highly correlated with each other using the traning dataset"""

# Define a correlation threshold
correlation_threshold = 0.9

# Initialize a set to store highly correlated feature pairs
highly_correlated_features = set()

# Identify highly correlated features
for i in range(len(correlation_matrix.columns)):
    for j in range(i):
        if abs(correlation_matrix.iloc[i, j]) > correlation_threshold:
            feature_name = correlation_matrix.columns[i]
            highly_correlated_features.add(feature_name)

print(highly_correlated_features)

"""Remove the previously identified highly correlated features from all the datasets"""

# Eliminate features that are highly correlated
train_features = train_features.drop(columns=highly_correlated_features)
valid_features = valid_features.drop(columns=highly_correlated_features)
test_features = test_features.drop(columns=highly_correlated_features)

"""Display the resulting feature shapes of the datasets"""

# Show the number of features after filtering in the training dataset
print("Number of features after filtering in training data: {}".format(train_features.shape))

# Show the number of features after filtering in the validation dataset
print("Number of features after filtering in validation data: {}".format(valid_features.shape))

# Show the number of features after filtering in the test dataset
print("Number of features after filtering in test data: {}".format(test_features.shape))

"""Identify the features that are highly correlated with the label using the traning dataset"""

# Compute the correlation between features and the first target label
correlation_with_target = train_features.corrwith(train_label1)

# Define a correlation threshold
correlation_threshold = 0.05

# Identify features that have a correlation above the threshold with the target label
highly_correlated_features = correlation_with_target[correlation_with_target.abs() > correlation_threshold]

print(highly_correlated_features)

"""Extract the features that are only highly correlated with the label from all datasets"""

# Remove features with low correlation from the training dataset
train_features = train_features[highly_correlated_features.index]

# Remove features with low correlation from the validation dataset
valid_features = valid_features[highly_correlated_features.index]

# Remove features with low correlation from the test dataset
test_features = test_features[highly_correlated_features.index]

"""Display the resulting feature shapes of the datasets"""

# Show the number of features after filtering in the training dataset
print("Number of features after filtering in training data: {}".format(train_features.shape))

# Show the number of features after filtering in the validation dataset
print("Number of features after filtering in validation data: {}".format(valid_features.shape))

# Show the number of features after filtering in the test dataset
print("Number of features after filtering in test data: {}".format(test_features.shape))

"""Standardize the features of all datasets"""

# Apply standardization to the features
feature_scaler = StandardScaler()
standardized_train_features = feature_scaler.fit_transform(train_features)
standardized_valid_features = feature_scaler.transform(valid_features)
standardized_test_features = feature_scaler.transform(test_features)

"""### Feature Extraction

Identify and retain the most influential features for predicting the label through Principal Component Analysis (PCA).

Select features that collectively account for 99% of the variance in the label.
"""

# Set the variance threshold to 99%
variance_threshold = 0.99

# Apply PCA with the determined number of components
pca = PCA(n_components=variance_threshold, svd_solver='full')

# Transform the standardized features using PCA
pca_train_result = pca.fit_transform(standardized_train_features)
pca_valid_result = pca.transform(standardized_valid_features)
pca_test_result = pca.transform(standardized_test_features)

# Get the explained variance ratio after dimensionality reduction
explained_variance_ratio_reduced = pca.explained_variance_ratio_
print("Explained Variance Ratio after Dimensionality Reduction:", explained_variance_ratio_reduced)

# Plot the explained variance ratio
plt.figure(figsize=(18, 10))
plt.bar(range(1, pca_train_result.shape[1] + 1), explained_variance_ratio_reduced, color='lightcoral')
plt.xlabel('Principal Component')
plt.ylabel('Explained Variance Ratio')
plt.title('Explained Variance Ratio per Principal Component')
plt.show()

# Display the reduced feature matrix shapes
print("Shape of Reduced Train Feature Matrix: {}".format(pca_train_result.shape))
print("Shape of Reduced Validation Feature Matrix: {}".format(pca_valid_result.shape))
print("Shape of Reduced Test Feature Matrix: {}".format(pca_test_result.shape))

"""## Model Selection

Select the model that best predicts the valid and test datasets based on accuracy, precision and recall
"""

# Define a list of classification models
classification_models = [
    ('K Neighbors', KNeighborsClassifier()),
    ('Decision Tree', DecisionTreeClassifier()),
    ('Random Forest', RandomForestClassifier()),
    ('SVM', SVC())
]

# The best model is SVM, followed by KNN, then Random Forest, and finally Decision Tree

# Get the number of features used in PCA
num_features = pca_train_result.shape[1]
print(f"Number of features: {num_features}\n")

# Assuming you have loaded your data into pca_train_result, train_label1,
# pca_valid_result, valid_label1, pca_test_result, and test_label1

# Concatenate pca_train_result and pca_valid_result
combined_train_data = np.concatenate((pca_train_result, pca_valid_result), axis=0)
combined_labels = np.concatenate((train_label1, valid_label1), axis=0)

# Define a function to calculate classification metrics
def calculate_classification_metrics(model, X, y):
    accuracy = cross_val_score(model, X, y, cv=5, scoring='accuracy').mean()
    precision = cross_val_score(model, X, y, cv=5, scoring='precision_weighted').mean()
    recall = cross_val_score(model, X, y, cv=5, scoring='recall_weighted').mean()
    return accuracy, precision, recall

# Loop through each classification model
for model_name, model in classification_models:
    print(f"Evaluating {model_name} using cross-validation:")
    
    # Calculate classification metrics using cross-validation
    accuracy, precision, recall = calculate_classification_metrics(model, combined_train_data, combined_labels)
    
    print(f"Mean Accuracy: {accuracy:.2f}")
    print(f"Mean Precision: {precision:.2f}")
    print(f"Mean Recall: {recall:.2f}")
    print("\n")

"""# Generate Output CSV

Define method to create the csv file
"""

# Define a function to create a DataFrame and save it as a CSV file
def create_csv(features, pred_before_fe, pred_after_fe, destination):
    # Determine the number of new features
    feature_count = features.shape[1]

    # Create column headers for the new features
    header_row = [f"new_feature_{i}" for i in range(1, feature_count + 1)]

    # Create a DataFrame with the new features and predictions
    df = pd.DataFrame(features, columns=header_row)

    # Insert columns for predicted labels before and after feature engineering
    df.insert(loc=0, column='Predicted labels before feature engineering', value=pred_before_fe)
    df.insert(loc=1, column='Predicted labels after feature engineering', value=pred_after_fe)

    # Insert a column for the number of new features
    df.insert(loc=2, column='No of new features', value=np.repeat(feature_count, features.shape[0]))

    # Save the DataFrame as a CSV file at the specified destination
    df.to_csv(destination, index=False)

"""Create CSV file"""

destination = '/content/drive/MyDrive/Colab Notebooks/Lab1/190676J_label_1.csv'

# create the csv output file
create_csv(pca_test_result, y_pred_base_test, y_pred_test, destination)

